# Test Advanced CTE (WITH) scenarios with COMPLEX type
# Grammar: WITH RECURSIVE, Multiple CTEs, Column Lists

--source include/villagesql/install_complex_extension.inc

CREATE TABLE t1 (val COMPLEX);
INSERT INTO t1 VALUES ('(1.0,2.0)'), ('(3.0,4.0)');

# 1. Multiple CTEs
WITH
  cte1 AS (SELECT val FROM t1 WHERE val = '(1.0,2.0)'),
  cte2 AS (SELECT val FROM t1 WHERE val = '(3.0,4.0)')
SELECT * FROM cte1 UNION ALL SELECT * FROM cte2;

# 2. CTE with explicit column list
WITH cte (my_val) AS (SELECT val FROM t1)
SELECT my_val FROM cte;

# 3. Recursive CTE with COMPLEX type
# TODO(villagesql): Once arithmetic operators are implemented for COMPLEX,
# update this test to generate new complex values in each recursion step
# (e.g., incrementing real/imaginary parts). For now, we just carry the
# value forward to test basic recursive CTE functionality.
WITH RECURSIVE cte (n, val) AS (
  SELECT 1, vsql_complex.complex_from_string('(1.0,2.0)')
  UNION ALL
  SELECT n + 1, val FROM cte WHERE n < 3
)
SELECT * FROM cte;

# 4. CTE in Subquery
SELECT * FROM (
  WITH cte AS (SELECT val FROM t1)
  SELECT * FROM cte
) AS dt;

# 5. CTE with Set Operations
WITH cte AS (
  SELECT val FROM t1
  UNION
  SELECT vsql_complex.complex_from_string('(5.0,6.0)')
)
SELECT * FROM cte;

DROP TABLE t1;

--source include/villagesql/uninstall_complex_extension.inc
