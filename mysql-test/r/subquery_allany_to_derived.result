WL#13052: Transform table subqueries using derived tables
CREATE TABLE it
(pk    INTEGER PRIMARY KEY,
val   INTEGER NOT NULL,
valn  INTEGER,
nulls INTEGER
);
CREATE TABLE ot(
v INTEGER NOT NULL,
vn INTEGER);
CREATE TABLE itr
(rf    INTEGER,
pki   INTEGER,
val   INTEGER NOT NULL,
valn  INTEGER,
nulls INTEGER,
PRIMARY KEY(rf, pki)
);
CREATE TABLE otr(
rf INTEGER,
v INTEGER NOT NULL,
vn INTEGER);
CREATE TABLE t0row(v INTEGER NOT NULL);
CREATE TABLE t1row(v INTEGER NOT NULL, n INTEGER);
CREATE TABLE t2row(v INTEGER NOT NULL, vn INTEGER, n INTEGER);
CREATE TABLE t3row(v INTEGER NOT NULL, vn INTEGER, n INTEGER);
CREATE TABLE t4row(v INTEGER NOT NULL, vn INTEGER, n INTEGER);
INSERT INTO it(pk, val, valn, nulls) VALUES
(1, 1,    1, NULL),
(2, 2,    2, NULL),
(3, 3, NULL, NULL);
INSERT INTO ot VALUES (0, 0), (1, 1), (2, 2), (3, 3), (4, NULL);
INSERT INTO itr SELECT 1, pk, val, valn, nulls FROM it;
INSERT INTO itr SELECT 2, pk, val, valn, nulls FROM it;
INSERT INTO otr SELECT 1, v, vn FROM ot;
INSERT INTO otr SELECT 2, v, vn FROM ot;
INSERT INTO t1row VALUES (2, NULL);
INSERT INTO t2row VALUES (2, 2, NULL), (2, NULL, NULL);
INSERT INTO t3row VALUES (2, 2, NULL), (2, 2, NULL), (2, NULL, NULL);
INSERT INTO t4row VALUES
(2, 2, NULL), (2, 2, NULL), (2, NULL, NULL), (3, 3, NULL);
ANALYZE TABLE it, ot, t1row, t2row, t3row, t4row;
Table	Op	Msg_type	Msg_text
test.it	analyze	status	OK
test.ot	analyze	status	OK
test.t1row	analyze	status	OK
test.t2row	analyze	status	OK
test.t3row	analyze	status	OK
test.t4row	analyze	status	OK

# -------------------------------------------------------------------#
# Test quantified comparison predicates with subquery_to_derived OFF #
# -------------------------------------------------------------------#


# quantified comparison predicate in SELECT list
# non-nullable columns
# no dependent subquery predicate

SELECT v <>ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
1
explain format=tree SELECT v <>ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.v = `<materialized_subquery>`.val))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = ot.v)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT v >ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v >=ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
1
explain format=tree SELECT v >=ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v <ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v <ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v <=ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
1
explain format=tree SELECT v <=ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v =ANY (SELECT val FROM it) AS b
FROM ot;
b
0
0
1
1
1
explain format=tree SELECT v =ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.v = `<materialized_subquery>`.val))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = ot.v)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT v >ANY (SELECT val FROM it) AS b
FROM ot;
b
0
0
1
1
1
explain format=tree SELECT v >ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v >=ANY (SELECT val FROM it) AS b
FROM ot;
b
0
1
1
1
1
explain format=tree SELECT v >=ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v <ANY (SELECT val FROM it) AS b
FROM ot;
b
0
0
1
1
1
explain format=tree SELECT v <ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v <=ANY (SELECT val FROM it) AS b
FROM ot;
b
0
1
1
1
1
explain format=tree SELECT v <=ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v =ALL (SELECT v FROM t0row) AS b
FROM ot;
b
1
1
1
1
1
explain format=tree SELECT v =ALL (SELECT v FROM t0row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t0row.v)  (rows=1)
            -> Table scan on t0row  (rows=1)

SELECT v =ALL (SELECT v FROM t1row) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v =ALL (SELECT v FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t1row.v)  (rows=1)
            -> Table scan on t1row  (rows=1)

SELECT v =ALL (SELECT v FROM t2row) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v =ALL (SELECT v FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t2row.v)  (rows=1)
            -> Table scan on t2row  (rows=2)

SELECT v =ALL (SELECT v FROM t4row) AS b
FROM ot;
b
0
0
0
0
0
explain format=tree SELECT v =ALL (SELECT v FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t4row.v)  (rows=3)
            -> Table scan on t4row  (rows=4)

SELECT v <>ANY (SELECT v FROM t0row) AS b
FROM ot;
b
0
0
0
0
0
explain format=tree SELECT v <>ANY (SELECT v FROM t0row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t0row.v)  (rows=1)
            -> Table scan on t0row  (rows=1)

SELECT v <>ANY (SELECT v FROM t1row) AS b
FROM ot;
b
0
1
1
1
1
explain format=tree SELECT v <>ANY (SELECT v FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t1row.v)  (rows=1)
            -> Table scan on t1row  (rows=1)

SELECT v <>ANY (SELECT v FROM t2row) AS b
FROM ot;
b
0
1
1
1
1
explain format=tree SELECT v <>ANY (SELECT v FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t2row.v)  (rows=1)
            -> Table scan on t2row  (rows=2)

SELECT v <>ANY (SELECT v FROM t4row) AS b
FROM ot;
b
1
1
1
1
1
explain format=tree SELECT v <>ANY (SELECT v FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t4row.v)  (rows=3)
            -> Table scan on t4row  (rows=4)


# quantified comparison predicate in SELECT list
# nullable outer column
# no dependent subquery predicate

SELECT vn <>ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
NULL
explain format=tree SELECT vn <>ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.vn = `<materialized_subquery>`.val))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = ot.vn)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT vn >ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT vn >ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <= it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn >=ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
NULL
explain format=tree SELECT vn >=ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) < it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn <ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
NULL
explain format=tree SELECT vn <ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) >= it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn <=ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
1
1
NULL
explain format=tree SELECT vn <=ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) > it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn =ANY (SELECT val FROM it) AS b
FROM ot;
b
0
1
1
1
NULL
explain format=tree SELECT vn =ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.vn = `<materialized_subquery>`.val))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = ot.vn)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT vn >ANY (SELECT val FROM it) AS b
FROM ot;
b
0
0
1
1
NULL
explain format=tree SELECT vn >ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) > it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn >=ANY (SELECT val FROM it) AS b
FROM ot;
b
0
1
1
1
NULL
explain format=tree SELECT vn >=ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) >= it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn <ANY (SELECT val FROM it) AS b
FROM ot;
b
0
1
1
1
NULL
explain format=tree SELECT vn <ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) < it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn <=ANY (SELECT val FROM it) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT vn <=ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <= it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn =ALL (SELECT v FROM t0row) AS b
FROM ot;
b
1
1
1
1
1
explain format=tree SELECT vn =ALL (SELECT v FROM t0row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t0row.v), true)  (rows=1)
            -> Table scan on t0row  (rows=1)

SELECT vn =ALL (SELECT v FROM t1row) AS b
FROM ot;
b
0
0
0
1
NULL
explain format=tree SELECT vn =ALL (SELECT v FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t1row.v), true)  (rows=1)
            -> Table scan on t1row  (rows=1)

SELECT vn =ALL (SELECT v FROM t2row) AS b
FROM ot;
b
0
0
0
1
NULL
explain format=tree SELECT vn =ALL (SELECT v FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t2row.v), true)  (rows=2)
            -> Table scan on t2row  (rows=2)

SELECT vn =ALL (SELECT v FROM t4row) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT vn =ALL (SELECT v FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t4row.v), true)  (rows=4)
            -> Table scan on t4row  (rows=4)

SELECT vn <>ANY (SELECT v FROM t0row) AS b
FROM ot;
b
0
0
0
0
0
explain format=tree SELECT vn <>ANY (SELECT v FROM t0row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t0row.v), true)  (rows=1)
            -> Table scan on t0row  (rows=1)

SELECT vn <>ANY (SELECT v FROM t1row) AS b
FROM ot;
b
0
1
1
1
NULL
explain format=tree SELECT vn <>ANY (SELECT v FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t1row.v), true)  (rows=1)
            -> Table scan on t1row  (rows=1)

SELECT vn <>ANY (SELECT v FROM t2row) AS b
FROM ot;
b
0
1
1
1
NULL
explain format=tree SELECT vn <>ANY (SELECT v FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t2row.v), true)  (rows=2)
            -> Table scan on t2row  (rows=2)

SELECT vn <>ANY (SELECT v FROM t4row) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT vn <>ANY (SELECT v FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t4row.v), true)  (rows=4)
            -> Table scan on t4row  (rows=4)


# quantified comparison predicate in SELECT list
# nullable column in subquery
# no dependent subquery predicate

SELECT v <>ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
NULL
NULL
NULL
explain format=tree SELECT v <>ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.v = `<materialized_subquery>`.valn))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.v)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT v >ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT v >ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) <= it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v >=ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
NULL
NULL
NULL
explain format=tree SELECT v >=ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) < it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v <ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT v <ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) >= it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v <=ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT v <=ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) > it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v =ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
NULL
NULL
NULL
explain format=tree SELECT v =ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.v = `<materialized_subquery>`.valn))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.v)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT v >ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT v >ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) > it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v >=ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT v >=ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) >= it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v <ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
NULL
NULL
NULL
explain format=tree SELECT v <ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) < it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v <=ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT v <=ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) <= it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v =ALL (SELECT n FROM t1row) AS b
FROM ot;
b
NULL
NULL
NULL
NULL
NULL
explain format=tree SELECT v =ALL (SELECT n FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t1row.n)  (rows=1)
            -> Filter: ((<cache>(ot.v) <> t1row.n) or (t1row.n is null))  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT v =ALL (SELECT vn FROM t2row) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT v =ALL (SELECT vn FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t2row.vn)  (rows=1.5)
            -> Filter: ((<cache>(ot.v) <> t2row.vn) or (t2row.vn is null))  (rows=1.5)
                -> Table scan on t2row  (rows=2)

SELECT v =ALL (SELECT vn FROM t3row) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT v =ALL (SELECT vn FROM t3row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t3row.vn)  (rows=2.33)
            -> Filter: ((<cache>(ot.v) <> t3row.vn) or (t3row.vn is null))  (rows=2.33)
                -> Table scan on t3row  (rows=3)

SELECT v =ALL (SELECT vn FROM t4row) AS b
FROM ot;
b
0
0
0
0
0
explain format=tree SELECT v =ALL (SELECT vn FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t4row.vn)  (rows=3.25)
            -> Filter: ((<cache>(ot.v) <> t4row.vn) or (t4row.vn is null))  (rows=3.25)
                -> Table scan on t4row  (rows=4)

SELECT v <>ANY (SELECT n FROM t1row) AS b
FROM ot;
b
NULL
NULL
NULL
NULL
NULL
explain format=tree SELECT v <>ANY (SELECT n FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t1row.n)  (rows=1)
            -> Filter: ((<cache>(ot.v) <> t1row.n) or (t1row.n is null))  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT v <>ANY (SELECT vn FROM t2row) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT v <>ANY (SELECT vn FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t2row.vn)  (rows=1.5)
            -> Filter: ((<cache>(ot.v) <> t2row.vn) or (t2row.vn is null))  (rows=1.5)
                -> Table scan on t2row  (rows=2)

SELECT v <>ANY (SELECT vn FROM t3row) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT v <>ANY (SELECT vn FROM t3row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t3row.vn)  (rows=2.33)
            -> Filter: ((<cache>(ot.v) <> t3row.vn) or (t3row.vn is null))  (rows=2.33)
                -> Table scan on t3row  (rows=3)

SELECT v <>ANY (SELECT vn FROM t4row) AS b
FROM ot;
b
1
1
1
1
1
explain format=tree SELECT v <>ANY (SELECT vn FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t4row.vn)  (rows=3.25)
            -> Filter: ((<cache>(ot.v) <> t4row.vn) or (t4row.vn is null))  (rows=3.25)
                -> Table scan on t4row  (rows=4)


# quantified comparison predicate in SELECT list
# nullable columns
# no dependent subquery predicate

SELECT vn <>ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
NULL
NULL
NULL
explain format=tree SELECT vn <>ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.vn = `<materialized_subquery>`.valn))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.vn)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT vn >ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT vn >ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <= it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn >=ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
NULL
NULL
NULL
explain format=tree SELECT vn >=ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) < it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn <ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT vn <ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) >= it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn <=ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
NULL
NULL
NULL
explain format=tree SELECT vn <=ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) > it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn =ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
NULL
NULL
NULL
explain format=tree SELECT vn =ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.vn = `<materialized_subquery>`.valn))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.vn)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT vn >ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
NULL
NULL
NULL
explain format=tree SELECT vn >ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) > it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn >=ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT vn >=ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) >= it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn <ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
NULL
NULL
NULL
explain format=tree SELECT vn <ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) < it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn <=ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT vn <=ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <= it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn =ALL (SELECT n FROM t1row) AS b
FROM ot;
b
NULL
NULL
NULL
NULL
NULL
explain format=tree SELECT vn =ALL (SELECT n FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t1row.n), true)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t1row.n) or (t1row.n is null)), true)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT vn =ALL (SELECT vn FROM t2row) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT vn =ALL (SELECT vn FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t2row.vn), true)  (rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t2row.vn) or (t2row.vn is null)), true)  (rows=2)
                -> Table scan on t2row  (rows=2)

SELECT vn =ALL (SELECT vn FROM t3row) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT vn =ALL (SELECT vn FROM t3row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t3row.vn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t3row.vn) or (t3row.vn is null)), true)  (rows=3)
                -> Table scan on t3row  (rows=3)

SELECT vn =ALL (SELECT vn FROM t4row) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT vn =ALL (SELECT vn FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t4row.vn), true)  (rows=4)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t4row.vn) or (t4row.vn is null)), true)  (rows=4)
                -> Table scan on t4row  (rows=4)

SELECT vn <>ANY (SELECT n FROM t1row) AS b
FROM ot;
b
NULL
NULL
NULL
NULL
NULL
explain format=tree SELECT vn <>ANY (SELECT n FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t1row.n), true)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t1row.n) or (t1row.n is null)), true)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT vn <>ANY (SELECT vn FROM t2row) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT vn <>ANY (SELECT vn FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t2row.vn), true)  (rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t2row.vn) or (t2row.vn is null)), true)  (rows=2)
                -> Table scan on t2row  (rows=2)

SELECT vn <>ANY (SELECT vn FROM t3row) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT vn <>ANY (SELECT vn FROM t3row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t3row.vn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t3row.vn) or (t3row.vn is null)), true)  (rows=3)
                -> Table scan on t3row  (rows=3)

SELECT vn <>ANY (SELECT vn FROM t4row) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT vn <>ANY (SELECT vn FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t4row.vn), true)  (rows=4)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t4row.vn) or (t4row.vn is null)), true)  (rows=4)
                -> Table scan on t4row  (rows=4)


# quantified comparison predicate in WHERE clause
# non-nullable columns
# no dependent subquery predicate

SELECT *
FROM ot
WHERE v <>ALL (SELECT val FROM it);
v	vn
0	0
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ALL (SELECT val FROM it);
EXPLAIN
-> Hash antijoin (it.val = ot.v)  (rows=15)
    -> Table scan on ot  (rows=5)
    -> Hash
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.v <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >=ALL (SELECT val FROM it);
v	vn
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >=ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.v < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <ALL (SELECT val FROM it);
v	vn
0	0
explain format=tree SELECT *
FROM ot
WHERE v <ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.v >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <=ALL (SELECT val FROM it);
v	vn
0	0
1	1
explain format=tree SELECT *
FROM ot
WHERE v <=ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.v > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v =ANY (SELECT val FROM it);
v	vn
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE v =ANY (SELECT val FROM it);
EXPLAIN
-> Remove duplicate ot rows using temporary table (weedout)  (rows=3)
    -> Inner hash join (ot.v = it.val)  (rows=3)
        -> Table scan on ot  (rows=5)
        -> Hash
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ANY (SELECT val FROM it);
v	vn
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.v > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >=ANY (SELECT val FROM it);
v	vn
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >=ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.v >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <ANY (SELECT val FROM it);
v	vn
0	0
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE v <ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.v < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <=ANY (SELECT val FROM it);
v	vn
0	0
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE v <=ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.v <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t0row);
v	vn
0	0
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t0row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t0row.v)  (rows=1)
                -> Table scan on t0row  (rows=1)

SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t1row);
v	vn
2	2
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t1row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t1row.v)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t2row);
v	vn
2	2
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t2row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t2row.v)  (rows=1)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t4row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t4row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t4row.v)  (rows=3)
                -> Table scan on t4row  (rows=4)

SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t0row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t0row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t0row.v)  (rows=1)
                -> Table scan on t0row  (rows=1)

SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t1row);
v	vn
0	0
1	1
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t1row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t1row.v)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t2row);
v	vn
0	0
1	1
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t2row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t2row.v)  (rows=1)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t4row);
v	vn
0	0
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t4row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t4row.v)  (rows=3)
                -> Table scan on t4row  (rows=4)


# quantified comparison predicate in WHERE clause
# nullable outer column
# no dependent subquery predicate

SELECT *
FROM ot
WHERE vn <>ALL (SELECT val FROM it);
v	vn
0	0
explain format=tree SELECT *
FROM ot
WHERE vn <>ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <in_optimizer>(ot.vn,ot.vn in (select #2) is false)  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((ot.vn = `<materialized_subquery>`.val))  (rows=1)
            -> Limit: 1 row(s)  (rows=1)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = ot.vn)
                    -> Materialize with deduplication  (rows=3)
                        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >ALL (SELECT val FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn >ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.vn <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >=ALL (SELECT val FROM it);
v	vn
3	3
explain format=tree SELECT *
FROM ot
WHERE vn >=ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.vn < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <ALL (SELECT val FROM it);
v	vn
0	0
explain format=tree SELECT *
FROM ot
WHERE vn <ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.vn >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <=ALL (SELECT val FROM it);
v	vn
0	0
1	1
explain format=tree SELECT *
FROM ot
WHERE vn <=ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.vn > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn =ANY (SELECT val FROM it);
v	vn
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn =ANY (SELECT val FROM it);
EXPLAIN
-> Remove duplicate ot rows using temporary table (weedout)  (rows=3)
    -> Inner hash join (ot.vn = it.val)  (rows=3)
        -> Table scan on ot  (rows=5)
        -> Hash
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >ANY (SELECT val FROM it);
v	vn
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn >ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >=ANY (SELECT val FROM it);
v	vn
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn >=ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <ANY (SELECT val FROM it);
v	vn
0	0
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE vn <ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <=ANY (SELECT val FROM it);
v	vn
0	0
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <=ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t0row);
v	vn
0	0
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t0row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t0row.v), true)  (rows=1)
                -> Table scan on t0row  (rows=1)

SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t1row);
v	vn
2	2
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t1row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t1row.v), true)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t2row);
v	vn
2	2
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t2row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t2row.v), true)  (rows=2)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t4row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t4row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t4row.v), true)  (rows=4)
                -> Table scan on t4row  (rows=4)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t0row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t0row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t0row.v)  (rows=1)
                -> Table scan on t0row  (rows=1)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t1row);
v	vn
0	0
1	1
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t1row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t1row.v)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t2row);
v	vn
0	0
1	1
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t2row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t2row.v)  (rows=1)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t4row);
v	vn
0	0
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t4row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t4row.v)  (rows=3)
                -> Table scan on t4row  (rows=4)


# quantified comparison predicate in WHERE clause
# nullable column in subquery
# no dependent subquery predicate

SELECT *
FROM ot
WHERE v <>ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v <>ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <in_optimizer>(ot.v,ot.v in (select #2) is false)  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((ot.v = `<materialized_subquery>`.valn))  (rows=1)
            -> Limit: 1 row(s)  (rows=1)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.v)
                    -> Materialize with deduplication  (rows=3)
                        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.v <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >=ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v >=ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.v < <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v <ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.v >= <min>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <=ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v <=ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.v > <min>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v =ANY (SELECT valn FROM it);
v	vn
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE v =ANY (SELECT valn FROM it);
EXPLAIN
-> Remove duplicate ot rows using temporary table (weedout)  (rows=3)
    -> Inner hash join (ot.v = it.valn)  (rows=3)
        -> Table scan on ot  (rows=5)
        -> Hash
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ANY (SELECT valn FROM it);
v	vn
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.v > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >=ANY (SELECT valn FROM it);
v	vn
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >=ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.v >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <ANY (SELECT valn FROM it);
v	vn
0	0
1	1
explain format=tree SELECT *
FROM ot
WHERE v <ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.v < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <=ANY (SELECT valn FROM it);
v	vn
0	0
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE v <=ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.v <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v =ALL (SELECT n FROM t1row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT n FROM t1row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <is_not_null_test>(t1row.n)  (rows=1)
                -> Filter: ((<cache>(ot.v) <> t1row.n) or (t1row.n is null))  (rows=1)
                    -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t2row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t2row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <is_not_null_test>(t2row.vn)  (rows=1.5)
                -> Filter: ((<cache>(ot.v) <> t2row.vn) or (t2row.vn is null))  (rows=1.5)
                    -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t3row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t3row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <is_not_null_test>(t3row.vn)  (rows=2.33)
                -> Filter: ((<cache>(ot.v) <> t3row.vn) or (t3row.vn is null))  (rows=2.33)
                    -> Table scan on t3row  (rows=3)

SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t4row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t4row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <is_not_null_test>(t4row.vn)  (rows=3.25)
                -> Filter: ((<cache>(ot.v) <> t4row.vn) or (t4row.vn is null))  (rows=3.25)
                    -> Table scan on t4row  (rows=4)

SELECT *
FROM ot
WHERE v <>ANY (SELECT n FROM t1row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT n FROM t1row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t1row.n)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t2row);
v	vn
0	0
1	1
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t2row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t2row.vn)  (rows=1)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t3row);
v	vn
0	0
1	1
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t3row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t3row.vn)  (rows=2)
                -> Table scan on t3row  (rows=3)

SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t4row);
v	vn
0	0
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t4row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t4row.vn)  (rows=3)
                -> Table scan on t4row  (rows=4)


# quantified comparison predicate in WHERE clause
# nullable columns
# no dependent subquery predicate

SELECT *
FROM ot
WHERE vn <>ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn <>ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <in_optimizer>(ot.vn,ot.vn in (select #2) is false)  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((ot.vn = `<materialized_subquery>`.valn))  (rows=1)
            -> Limit: 1 row(s)  (rows=1)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.vn)
                    -> Materialize with deduplication  (rows=3)
                        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn >ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.vn <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >=ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn >=ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.vn < <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn <ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.vn >= <min>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <=ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn <=ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.vn > <min>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn =ANY (SELECT valn FROM it);
v	vn
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE vn =ANY (SELECT valn FROM it);
EXPLAIN
-> Remove duplicate ot rows using temporary table (weedout)  (rows=3)
    -> Inner hash join (ot.vn = it.valn)  (rows=3)
        -> Table scan on ot  (rows=5)
        -> Hash
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >ANY (SELECT valn FROM it);
v	vn
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn >ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >=ANY (SELECT valn FROM it);
v	vn
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn >=ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <ANY (SELECT valn FROM it);
v	vn
0	0
1	1
explain format=tree SELECT *
FROM ot
WHERE vn <ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <=ANY (SELECT valn FROM it);
v	vn
0	0
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE vn <=ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn =ALL (SELECT n FROM t1row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT n FROM t1row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t1row.n), true)  (rows=1)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t1row.n) or (t1row.n is null)), true)  (rows=1)
                    -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t2row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t2row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t2row.vn), true)  (rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t2row.vn) or (t2row.vn is null)), true)  (rows=2)
                    -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t3row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t3row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t3row.vn), true)  (rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t3row.vn) or (t3row.vn is null)), true)  (rows=3)
                    -> Table scan on t3row  (rows=3)

SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t4row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t4row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t4row.vn), true)  (rows=4)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t4row.vn) or (t4row.vn is null)), true)  (rows=4)
                    -> Table scan on t4row  (rows=4)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT n FROM t1row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT n FROM t1row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t1row.n)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t2row);
v	vn
0	0
1	1
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t2row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t2row.vn)  (rows=1)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t3row);
v	vn
0	0
1	1
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t3row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t3row.vn)  (rows=2)
                -> Table scan on t3row  (rows=3)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t4row);
v	vn
0	0
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t4row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t4row.vn)  (rows=3)
                -> Table scan on t4row  (rows=4)

#
# Some negative testing
#
# No tables in outer query block
SELECT 1, 1 >ANY (SELECT val FROM it) AS q1, 2 >ANY (SELECT val FROM it) AS q2;
1	q1	q2
1	0	1
explain format=tree SELECT 1, 1 >ANY (SELECT val FROM it) AS q1, 2 >ANY (SELECT val FROM it) AS q2;
EXPLAIN
-> Rows fetched before execution  (rows=1)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)
-> Select #3 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT 1 WHERE 2 >ANY (SELECT val FROM it);
1
1
explain format=tree SELECT 1 WHERE 2 >ANY (SELECT val FROM it);
EXPLAIN
-> Rows fetched before execution  (rows=1)

# No tables in inner query block
SELECT 1, 1 >ANY (SELECT 0) AS q1 FROM ot;
1	q1
1	1
1	1
1	1
1	1
1	1
explain format=tree SELECT 1, 1 >ANY (SELECT 0) AS q1 FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Rows fetched before execution  (rows=1)

SELECT 1 FROM ot WHERE 1 >ANY (SELECT 0);
1
1
1
1
1
1
explain format=tree SELECT 1 FROM ot WHERE 1 >ANY (SELECT 0);
EXPLAIN
-> Table scan on ot  (rows=5)

# Set operation in subquery
SELECT v >ALL (SELECT val FROM it UNION SELECT val FROM it) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT val FROM it UNION SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Table scan on <union temporary>  (rows=6)
        -> Union materialize with deduplication  (rows=6)
            -> Table scan on it  (rows=3)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it UNION SELECT val FROM it);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it UNION SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.v <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on <union temporary>  (rows=6)
            -> Union materialize with deduplication  (rows=6)
                -> Table scan on it  (rows=3)
                -> Table scan on it  (rows=3)

# Implicitly grouped subquery
SELECT v >ALL (SELECT MAX(val) FROM it) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT MAX(val) FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <= <ref_null_helper>(max(it.val)))  (rows=1)
            -> Aggregate: max(it.val)  (rows=1)
                -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(val) FROM it);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(val) FROM it);
EXPLAIN
-> Filter: <not>((ot.v <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

# Explicitly grouped subquery
SELECT v >ALL (SELECT val FROM it GROUP BY val) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT val FROM it GROUP BY val) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it GROUP BY val);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it GROUP BY val);
EXPLAIN
-> Filter: <not>((ot.v <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT v >ALL (SELECT MAX(valn) FROM it GROUP BY val) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT v >ALL (SELECT MAX(valn) FROM it GROUP BY val) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)
        -> Filter: (<cache>(ot.v) <= <ref_null_helper>(max(it.valn)))
            -> Table scan on <temporary>
                -> Aggregate using temporary table
                    -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(valn) FROM it GROUP BY val);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(valn) FROM it GROUP BY val);
EXPLAIN
-> Filter: <not>((ot.v <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on <temporary>
            -> Aggregate using temporary table
                -> Table scan on it  (rows=3)

# Subquery with WINDOW function
SELECT v >ALL (SELECT MAX(val) OVER () FROM it) AS b
FROM ot;
ERROR 42000: This version of MySQL doesn't yet support 'the combination of this ALL/ANY/SOME/IN subquery with this comparison operator and with contained window functions'
SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(val) OVER () FROM it);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(val) OVER () FROM it);
EXPLAIN
-> Filter: <not>((ot.v <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Window aggregate with buffering: max(it.val) OVER ()   (rows=3)
            -> Table scan on it  (rows=3)

# Subquery with LIMIT (unsupported) and ORDER BY (supported)
SELECT v >ALL (SELECT val FROM it LIMIT 3) AS b
FROM ot;
ERROR 42000: This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it LIMIT 3);
ERROR 42000: This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
SELECT v >ALL (SELECT val FROM it ORDER BY val DESC) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT val FROM it ORDER BY val DESC) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it ORDER BY val DESC);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it ORDER BY val DESC);
EXPLAIN
-> Filter: <not>((ot.v <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT v >ALL (SELECT val FROM it ORDER BY val DESC LIMIT 3) AS b
FROM ot;
ERROR 42000: This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it ORDER BY val DESC LIMIT 3);
ERROR 42000: This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
# Subquery with outer reference in SELECT list
SELECT v >ALL (SELECT val FROM itr WHERE otr.rf = itr.rf) AS b
FROM otr
WHERE rf = 1;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT val FROM itr WHERE otr.rf = itr.rf) AS b
FROM otr
WHERE rf = 1;
EXPLAIN
-> Filter: (otr.rf = 1)  (rows=1)
    -> Table scan on otr  (rows=10)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=0.333)
        -> Filter: (<cache>(otr.v) <= itr.val)  (rows=0.333)
            -> Index lookup on itr using PRIMARY (rf = otr.rf)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.otr.rf' of SELECT #2 was resolved in SELECT #1
SELECT vn >ALL (SELECT valn FROM itr WHERE otr.rf = itr.rf) AS b
FROM otr
WHERE rf = 1;
b
0
0
0
NULL
NULL
explain format=tree SELECT vn >ALL (SELECT valn FROM itr WHERE otr.rf = itr.rf) AS b
FROM otr
WHERE rf = 1;
EXPLAIN
-> Filter: (otr.rf = 1)  (rows=1)
    -> Table scan on otr  (rows=10)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(itr.valn), true)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(otr.vn) <= itr.valn) or (itr.valn is null)), true)  (rows=1)
                -> Index lookup on itr using PRIMARY (rf = otr.rf)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.otr.rf' of SELECT #2 was resolved in SELECT #1
# Subquery with outer reference in WHERE clause
SELECT *
FROM otr
WHERE v >ALL (SELECT val FROM itr WHERE otr.rf = itr.rf);
rf	v	vn
1	4	NULL
2	4	NULL
explain format=tree SELECT *
FROM otr
WHERE v >ALL (SELECT val FROM itr WHERE otr.rf = itr.rf);
EXPLAIN
-> Filter: <not>(<in_optimizer>(otr.v,<exists>(select #2)))  (rows=10)
    -> Table scan on otr  (rows=10)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=0.333)
            -> Filter: (<cache>(otr.v) <= itr.val)  (rows=0.333)
                -> Index lookup on itr using PRIMARY (rf = otr.rf)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.otr.rf' of SELECT #2 was resolved in SELECT #1
SELECT *
FROM otr
WHERE vn >ALL (SELECT valn FROM itr WHERE otr.rf = itr.rf);
rf	v	vn
explain format=tree SELECT *
FROM otr
WHERE vn >ALL (SELECT valn FROM itr WHERE otr.rf = itr.rf);
EXPLAIN
-> Filter: <not>(<in_optimizer>(otr.vn,<exists>(select #2)))  (rows=10)
    -> Table scan on otr  (rows=10)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(itr.valn), true)  (rows=1)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(otr.vn) <= itr.valn) or (itr.valn is null)), true)  (rows=1)
                    -> Index lookup on itr using PRIMARY (rf = otr.rf)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.otr.rf' of SELECT #2 was resolved in SELECT #1
set optimizer_switch='semijoin=off,subquery_to_derived=on';

# -------------------------------------------------------------------#
# Test quantified comparison predicates with subquery_to_derived ON  #
# -------------------------------------------------------------------#


# quantified comparison predicate in SELECT list
# non-nullable columns
# no dependent subquery predicate

SELECT v <>ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
1
explain format=tree SELECT v <>ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.v = `<materialized_subquery>`.val))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = ot.v)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT v >ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v >=ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
1
explain format=tree SELECT v >=ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v <ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v <ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v <=ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
1
explain format=tree SELECT v <=ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v =ANY (SELECT val FROM it) AS b
FROM ot;
b
0
0
1
1
1
explain format=tree SELECT v =ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.v = `<materialized_subquery>`.val))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = ot.v)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT v >ANY (SELECT val FROM it) AS b
FROM ot;
b
0
0
1
1
1
explain format=tree SELECT v >ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v >=ANY (SELECT val FROM it) AS b
FROM ot;
b
0
1
1
1
1
explain format=tree SELECT v >=ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v <ANY (SELECT val FROM it) AS b
FROM ot;
b
0
0
1
1
1
explain format=tree SELECT v <ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v <=ANY (SELECT val FROM it) AS b
FROM ot;
b
0
1
1
1
1
explain format=tree SELECT v <=ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT v =ALL (SELECT v FROM t0row) AS b
FROM ot;
b
1
1
1
1
1
explain format=tree SELECT v =ALL (SELECT v FROM t0row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t0row.v)  (rows=1)
            -> Table scan on t0row  (rows=1)

SELECT v =ALL (SELECT v FROM t1row) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v =ALL (SELECT v FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t1row.v)  (rows=1)
            -> Table scan on t1row  (rows=1)

SELECT v =ALL (SELECT v FROM t2row) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v =ALL (SELECT v FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t2row.v)  (rows=1)
            -> Table scan on t2row  (rows=2)

SELECT v =ALL (SELECT v FROM t4row) AS b
FROM ot;
b
0
0
0
0
0
explain format=tree SELECT v =ALL (SELECT v FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t4row.v)  (rows=3)
            -> Table scan on t4row  (rows=4)

SELECT v <>ANY (SELECT v FROM t0row) AS b
FROM ot;
b
0
0
0
0
0
explain format=tree SELECT v <>ANY (SELECT v FROM t0row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t0row.v)  (rows=1)
            -> Table scan on t0row  (rows=1)

SELECT v <>ANY (SELECT v FROM t1row) AS b
FROM ot;
b
0
1
1
1
1
explain format=tree SELECT v <>ANY (SELECT v FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t1row.v)  (rows=1)
            -> Table scan on t1row  (rows=1)

SELECT v <>ANY (SELECT v FROM t2row) AS b
FROM ot;
b
0
1
1
1
1
explain format=tree SELECT v <>ANY (SELECT v FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t2row.v)  (rows=1)
            -> Table scan on t2row  (rows=2)

SELECT v <>ANY (SELECT v FROM t4row) AS b
FROM ot;
b
1
1
1
1
1
explain format=tree SELECT v <>ANY (SELECT v FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <> t4row.v)  (rows=3)
            -> Table scan on t4row  (rows=4)


# quantified comparison predicate in SELECT list
# nullable outer column
# no dependent subquery predicate

SELECT vn <>ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
NULL
explain format=tree SELECT vn <>ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.vn = `<materialized_subquery>`.val))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = ot.vn)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT vn >ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT vn >ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <= it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn >=ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
NULL
explain format=tree SELECT vn >=ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) < it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn <ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
0
1
NULL
explain format=tree SELECT vn <ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) >= it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn <=ALL (SELECT val FROM it) AS b
FROM ot;
b
0
0
1
1
NULL
explain format=tree SELECT vn <=ALL (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) > it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn =ANY (SELECT val FROM it) AS b
FROM ot;
b
0
1
1
1
NULL
explain format=tree SELECT vn =ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.vn = `<materialized_subquery>`.val))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = ot.vn)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT vn >ANY (SELECT val FROM it) AS b
FROM ot;
b
0
0
1
1
NULL
explain format=tree SELECT vn >ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) > it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn >=ANY (SELECT val FROM it) AS b
FROM ot;
b
0
1
1
1
NULL
explain format=tree SELECT vn >=ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) >= it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn <ANY (SELECT val FROM it) AS b
FROM ot;
b
0
1
1
1
NULL
explain format=tree SELECT vn <ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) < it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn <=ANY (SELECT val FROM it) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT vn <=ANY (SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <= it.val), true)  (rows=3)
            -> Table scan on it  (rows=3)

SELECT vn =ALL (SELECT v FROM t0row) AS b
FROM ot;
b
1
1
1
1
1
explain format=tree SELECT vn =ALL (SELECT v FROM t0row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t0row.v), true)  (rows=1)
            -> Table scan on t0row  (rows=1)

SELECT vn =ALL (SELECT v FROM t1row) AS b
FROM ot;
b
0
0
0
1
NULL
explain format=tree SELECT vn =ALL (SELECT v FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t1row.v), true)  (rows=1)
            -> Table scan on t1row  (rows=1)

SELECT vn =ALL (SELECT v FROM t2row) AS b
FROM ot;
b
0
0
0
1
NULL
explain format=tree SELECT vn =ALL (SELECT v FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t2row.v), true)  (rows=2)
            -> Table scan on t2row  (rows=2)

SELECT vn =ALL (SELECT v FROM t4row) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT vn =ALL (SELECT v FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t4row.v), true)  (rows=4)
            -> Table scan on t4row  (rows=4)

SELECT vn <>ANY (SELECT v FROM t0row) AS b
FROM ot;
b
0
0
0
0
0
explain format=tree SELECT vn <>ANY (SELECT v FROM t0row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t0row.v), true)  (rows=1)
            -> Table scan on t0row  (rows=1)

SELECT vn <>ANY (SELECT v FROM t1row) AS b
FROM ot;
b
0
1
1
1
NULL
explain format=tree SELECT vn <>ANY (SELECT v FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t1row.v), true)  (rows=1)
            -> Table scan on t1row  (rows=1)

SELECT vn <>ANY (SELECT v FROM t2row) AS b
FROM ot;
b
0
1
1
1
NULL
explain format=tree SELECT vn <>ANY (SELECT v FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t2row.v), true)  (rows=2)
            -> Table scan on t2row  (rows=2)

SELECT vn <>ANY (SELECT v FROM t4row) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT vn <>ANY (SELECT v FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t4row.v), true)  (rows=4)
            -> Table scan on t4row  (rows=4)


# quantified comparison predicate in SELECT list
# nullable column in subquery
# no dependent subquery predicate

SELECT v <>ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
NULL
NULL
NULL
explain format=tree SELECT v <>ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.v = `<materialized_subquery>`.valn))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.v)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT v >ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT v >ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) <= it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v >=ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
NULL
NULL
NULL
explain format=tree SELECT v >=ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) < it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v <ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT v <ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) >= it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v <=ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT v <=ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) > it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v =ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
NULL
NULL
NULL
explain format=tree SELECT v =ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.v = `<materialized_subquery>`.valn))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.v)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT v >ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT v >ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) > it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v >=ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT v >=ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) >= it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v <ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
NULL
NULL
NULL
explain format=tree SELECT v <ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) < it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v <=ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT v <=ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(it.valn)  (rows=1.67)
            -> Filter: ((<cache>(ot.v) <= it.valn) or (it.valn is null))  (rows=1.67)
                -> Table scan on it  (rows=3)

SELECT v =ALL (SELECT n FROM t1row) AS b
FROM ot;
b
NULL
NULL
NULL
NULL
NULL
explain format=tree SELECT v =ALL (SELECT n FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t1row.n)  (rows=1)
            -> Filter: ((<cache>(ot.v) <> t1row.n) or (t1row.n is null))  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT v =ALL (SELECT vn FROM t2row) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT v =ALL (SELECT vn FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t2row.vn)  (rows=1.5)
            -> Filter: ((<cache>(ot.v) <> t2row.vn) or (t2row.vn is null))  (rows=1.5)
                -> Table scan on t2row  (rows=2)

SELECT v =ALL (SELECT vn FROM t3row) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT v =ALL (SELECT vn FROM t3row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t3row.vn)  (rows=2.33)
            -> Filter: ((<cache>(ot.v) <> t3row.vn) or (t3row.vn is null))  (rows=2.33)
                -> Table scan on t3row  (rows=3)

SELECT v =ALL (SELECT vn FROM t4row) AS b
FROM ot;
b
0
0
0
0
0
explain format=tree SELECT v =ALL (SELECT vn FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t4row.vn)  (rows=3.25)
            -> Filter: ((<cache>(ot.v) <> t4row.vn) or (t4row.vn is null))  (rows=3.25)
                -> Table scan on t4row  (rows=4)

SELECT v <>ANY (SELECT n FROM t1row) AS b
FROM ot;
b
NULL
NULL
NULL
NULL
NULL
explain format=tree SELECT v <>ANY (SELECT n FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t1row.n)  (rows=1)
            -> Filter: ((<cache>(ot.v) <> t1row.n) or (t1row.n is null))  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT v <>ANY (SELECT vn FROM t2row) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT v <>ANY (SELECT vn FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t2row.vn)  (rows=1.5)
            -> Filter: ((<cache>(ot.v) <> t2row.vn) or (t2row.vn is null))  (rows=1.5)
                -> Table scan on t2row  (rows=2)

SELECT v <>ANY (SELECT vn FROM t3row) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT v <>ANY (SELECT vn FROM t3row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t3row.vn)  (rows=2.33)
            -> Filter: ((<cache>(ot.v) <> t3row.vn) or (t3row.vn is null))  (rows=2.33)
                -> Table scan on t3row  (rows=3)

SELECT v <>ANY (SELECT vn FROM t4row) AS b
FROM ot;
b
1
1
1
1
1
explain format=tree SELECT v <>ANY (SELECT vn FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <is_not_null_test>(t4row.vn)  (rows=3.25)
            -> Filter: ((<cache>(ot.v) <> t4row.vn) or (t4row.vn is null))  (rows=3.25)
                -> Table scan on t4row  (rows=4)


# quantified comparison predicate in SELECT list
# nullable columns
# no dependent subquery predicate

SELECT vn <>ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
NULL
NULL
NULL
explain format=tree SELECT vn <>ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.vn = `<materialized_subquery>`.valn))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.vn)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT vn >ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT vn >ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <= it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn >=ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
NULL
NULL
NULL
explain format=tree SELECT vn >=ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) < it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn <ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT vn <ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) >= it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn <=ALL (SELECT valn FROM it) AS b
FROM ot;
b
0
0
NULL
NULL
NULL
explain format=tree SELECT vn <=ALL (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) > it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn =ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
NULL
NULL
NULL
explain format=tree SELECT vn =ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((ot.vn = `<materialized_subquery>`.valn))  (rows=1)
        -> Limit: 1 row(s)  (rows=1)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.vn)
                -> Materialize with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT vn >ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
NULL
NULL
NULL
explain format=tree SELECT vn >ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) > it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn >=ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT vn >=ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) >= it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn <ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
NULL
NULL
NULL
explain format=tree SELECT vn <ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) < it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn <=ANY (SELECT valn FROM it) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT vn <=ANY (SELECT valn FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(it.valn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <= it.valn) or (it.valn is null)), true)  (rows=3)
                -> Table scan on it  (rows=3)

SELECT vn =ALL (SELECT n FROM t1row) AS b
FROM ot;
b
NULL
NULL
NULL
NULL
NULL
explain format=tree SELECT vn =ALL (SELECT n FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t1row.n), true)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t1row.n) or (t1row.n is null)), true)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT vn =ALL (SELECT vn FROM t2row) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT vn =ALL (SELECT vn FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t2row.vn), true)  (rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t2row.vn) or (t2row.vn is null)), true)  (rows=2)
                -> Table scan on t2row  (rows=2)

SELECT vn =ALL (SELECT vn FROM t3row) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT vn =ALL (SELECT vn FROM t3row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t3row.vn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t3row.vn) or (t3row.vn is null)), true)  (rows=3)
                -> Table scan on t3row  (rows=3)

SELECT vn =ALL (SELECT vn FROM t4row) AS b
FROM ot;
b
0
0
0
0
NULL
explain format=tree SELECT vn =ALL (SELECT vn FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t4row.vn), true)  (rows=4)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t4row.vn) or (t4row.vn is null)), true)  (rows=4)
                -> Table scan on t4row  (rows=4)

SELECT vn <>ANY (SELECT n FROM t1row) AS b
FROM ot;
b
NULL
NULL
NULL
NULL
NULL
explain format=tree SELECT vn <>ANY (SELECT n FROM t1row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t1row.n), true)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t1row.n) or (t1row.n is null)), true)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT vn <>ANY (SELECT vn FROM t2row) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT vn <>ANY (SELECT vn FROM t2row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t2row.vn), true)  (rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t2row.vn) or (t2row.vn is null)), true)  (rows=2)
                -> Table scan on t2row  (rows=2)

SELECT vn <>ANY (SELECT vn FROM t3row) AS b
FROM ot;
b
1
1
1
NULL
NULL
explain format=tree SELECT vn <>ANY (SELECT vn FROM t3row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t3row.vn), true)  (rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t3row.vn) or (t3row.vn is null)), true)  (rows=3)
                -> Table scan on t3row  (rows=3)

SELECT vn <>ANY (SELECT vn FROM t4row) AS b
FROM ot;
b
1
1
1
1
NULL
explain format=tree SELECT vn <>ANY (SELECT vn FROM t4row) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t4row.vn), true)  (rows=4)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t4row.vn) or (t4row.vn is null)), true)  (rows=4)
                -> Table scan on t4row  (rows=4)


# quantified comparison predicate in WHERE clause
# non-nullable columns
# no dependent subquery predicate

SELECT *
FROM ot
WHERE v <>ALL (SELECT val FROM it);
v	vn
0	0
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ALL (SELECT val FROM it);
EXPLAIN
-> Filter: (derived_1_2.Name_exp_1 is null)  (rows=15)
    -> Nested loop antijoin  (rows=15)
        -> Table scan on ot  (rows=5)
        -> Covering index lookup on derived_1_2 using <auto_key0> (Name_exp_1 = ot.v)  (rows=2)
            -> Materialize  (rows=3)
                -> Table scan on <temporary>  (rows=3)
                    -> Temporary table with deduplication  (rows=3)
                        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.v <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >=ALL (SELECT val FROM it);
v	vn
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >=ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.v < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <ALL (SELECT val FROM it);
v	vn
0	0
explain format=tree SELECT *
FROM ot
WHERE v <ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.v >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <=ALL (SELECT val FROM it);
v	vn
0	0
1	1
explain format=tree SELECT *
FROM ot
WHERE v <=ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.v > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v =ANY (SELECT val FROM it);
v	vn
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE v =ANY (SELECT val FROM it);
EXPLAIN
-> Nested loop inner join  (rows=15)
    -> Table scan on ot  (rows=5)
    -> Covering index lookup on derived_1_2 using <auto_key0> (Name_exp_1 = ot.v)  (rows=2)
        -> Materialize  (rows=3)
            -> Table scan on <temporary>  (rows=3)
                -> Temporary table with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ANY (SELECT val FROM it);
v	vn
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.v > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >=ANY (SELECT val FROM it);
v	vn
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >=ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.v >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <ANY (SELECT val FROM it);
v	vn
0	0
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE v <ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.v < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <=ANY (SELECT val FROM it);
v	vn
0	0
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE v <=ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.v <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t0row);
v	vn
0	0
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t0row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t0row.v)  (rows=1)
                -> Table scan on t0row  (rows=1)

SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t1row);
v	vn
2	2
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t1row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t1row.v)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t2row);
v	vn
2	2
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t2row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t2row.v)  (rows=1)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t4row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT v FROM t4row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t4row.v)  (rows=3)
                -> Table scan on t4row  (rows=4)

SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t0row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t0row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t0row.v)  (rows=1)
                -> Table scan on t0row  (rows=1)

SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t1row);
v	vn
0	0
1	1
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t1row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t1row.v)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t2row);
v	vn
0	0
1	1
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t2row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t2row.v)  (rows=1)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t4row);
v	vn
0	0
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT v FROM t4row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t4row.v)  (rows=3)
                -> Table scan on t4row  (rows=4)


# quantified comparison predicate in WHERE clause
# nullable outer column
# no dependent subquery predicate

SELECT *
FROM ot
WHERE vn <>ALL (SELECT val FROM it);
v	vn
0	0
explain format=tree SELECT *
FROM ot
WHERE vn <>ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <in_optimizer>(ot.vn,ot.vn in (select #2) is false)  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((ot.vn = `<materialized_subquery>`.val))  (rows=1)
            -> Limit: 1 row(s)  (rows=1)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val = ot.vn)
                    -> Materialize with deduplication  (rows=3)
                        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >ALL (SELECT val FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn >ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.vn <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >=ALL (SELECT val FROM it);
v	vn
3	3
explain format=tree SELECT *
FROM ot
WHERE vn >=ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.vn < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <ALL (SELECT val FROM it);
v	vn
0	0
explain format=tree SELECT *
FROM ot
WHERE vn <ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.vn >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <=ALL (SELECT val FROM it);
v	vn
0	0
1	1
explain format=tree SELECT *
FROM ot
WHERE vn <=ALL (SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.vn > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn =ANY (SELECT val FROM it);
v	vn
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn =ANY (SELECT val FROM it);
EXPLAIN
-> Nested loop inner join  (rows=15)
    -> Filter: (ot.vn is not null)  (rows=5)
        -> Table scan on ot  (rows=5)
    -> Covering index lookup on derived_1_2 using <auto_key0> (Name_exp_1 = ot.vn)  (rows=2)
        -> Materialize  (rows=3)
            -> Table scan on <temporary>  (rows=3)
                -> Temporary table with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >ANY (SELECT val FROM it);
v	vn
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn >ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >=ANY (SELECT val FROM it);
v	vn
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn >=ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <ANY (SELECT val FROM it);
v	vn
0	0
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE vn <ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <=ANY (SELECT val FROM it);
v	vn
0	0
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <=ANY (SELECT val FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t0row);
v	vn
0	0
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t0row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t0row.v), true)  (rows=1)
                -> Table scan on t0row  (rows=1)

SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t1row);
v	vn
2	2
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t1row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t1row.v), true)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t2row);
v	vn
2	2
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t2row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t2row.v), true)  (rows=2)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t4row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT v FROM t4row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, (<cache>(ot.vn) <> t4row.v), true)  (rows=4)
                -> Table scan on t4row  (rows=4)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t0row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t0row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t0row.v)  (rows=1)
                -> Table scan on t0row  (rows=1)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t1row);
v	vn
0	0
1	1
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t1row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t1row.v)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t2row);
v	vn
0	0
1	1
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t2row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t2row.v)  (rows=1)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t4row);
v	vn
0	0
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT v FROM t4row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t4row.v)  (rows=3)
                -> Table scan on t4row  (rows=4)


# quantified comparison predicate in WHERE clause
# nullable column in subquery
# no dependent subquery predicate

SELECT *
FROM ot
WHERE v <>ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v <>ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <in_optimizer>(ot.v,ot.v in (select #2) is false)  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((ot.v = `<materialized_subquery>`.valn))  (rows=1)
            -> Limit: 1 row(s)  (rows=1)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.v)
                    -> Materialize with deduplication  (rows=3)
                        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.v <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >=ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v >=ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.v < <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v <ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.v >= <min>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <=ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v <=ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.v > <min>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v =ANY (SELECT valn FROM it);
v	vn
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE v =ANY (SELECT valn FROM it);
EXPLAIN
-> Nested loop inner join  (rows=15)
    -> Table scan on ot  (rows=5)
    -> Covering index lookup on derived_1_2 using <auto_key0> (Name_exp_1 = ot.v)  (rows=2)
        -> Materialize  (rows=3)
            -> Table scan on <temporary>  (rows=3)
                -> Temporary table with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ANY (SELECT valn FROM it);
v	vn
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.v > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >=ANY (SELECT valn FROM it);
v	vn
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >=ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.v >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <ANY (SELECT valn FROM it);
v	vn
0	0
1	1
explain format=tree SELECT *
FROM ot
WHERE v <ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.v < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v <=ANY (SELECT valn FROM it);
v	vn
0	0
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE v <=ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.v <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v =ALL (SELECT n FROM t1row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT n FROM t1row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <is_not_null_test>(t1row.n)  (rows=1)
                -> Filter: ((<cache>(ot.v) <> t1row.n) or (t1row.n is null))  (rows=1)
                    -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t2row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t2row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <is_not_null_test>(t2row.vn)  (rows=1.5)
                -> Filter: ((<cache>(ot.v) <> t2row.vn) or (t2row.vn is null))  (rows=1.5)
                    -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t3row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t3row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <is_not_null_test>(t3row.vn)  (rows=2.33)
                -> Filter: ((<cache>(ot.v) <> t3row.vn) or (t3row.vn is null))  (rows=2.33)
                    -> Table scan on t3row  (rows=3)

SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t4row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v =ALL (SELECT vn FROM t4row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <is_not_null_test>(t4row.vn)  (rows=3.25)
                -> Filter: ((<cache>(ot.v) <> t4row.vn) or (t4row.vn is null))  (rows=3.25)
                    -> Table scan on t4row  (rows=4)

SELECT *
FROM ot
WHERE v <>ANY (SELECT n FROM t1row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT n FROM t1row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t1row.n)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t2row);
v	vn
0	0
1	1
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t2row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t2row.vn)  (rows=1)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t3row);
v	vn
0	0
1	1
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t3row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t3row.vn)  (rows=2)
                -> Table scan on t3row  (rows=3)

SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t4row);
v	vn
0	0
1	1
2	2
3	3
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v <>ANY (SELECT vn FROM t4row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.v,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.v) <> t4row.vn)  (rows=3)
                -> Table scan on t4row  (rows=4)


# quantified comparison predicate in WHERE clause
# nullable columns
# no dependent subquery predicate

SELECT *
FROM ot
WHERE vn <>ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn <>ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <in_optimizer>(ot.vn,ot.vn in (select #2) is false)  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((ot.vn = `<materialized_subquery>`.valn))  (rows=1)
            -> Limit: 1 row(s)  (rows=1)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (valn = ot.vn)
                    -> Materialize with deduplication  (rows=3)
                        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn >ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.vn <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >=ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn >=ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.vn < <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn <ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.vn >= <min>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <=ALL (SELECT valn FROM it);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn <=ALL (SELECT valn FROM it);
EXPLAIN
-> Filter: <not>((ot.vn > <min>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn =ANY (SELECT valn FROM it);
v	vn
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE vn =ANY (SELECT valn FROM it);
EXPLAIN
-> Nested loop inner join  (rows=15)
    -> Filter: (ot.vn is not null)  (rows=5)
        -> Table scan on ot  (rows=5)
    -> Covering index lookup on derived_1_2 using <auto_key0> (Name_exp_1 = ot.vn)  (rows=2)
        -> Materialize  (rows=3)
            -> Table scan on <temporary>  (rows=3)
                -> Temporary table with deduplication  (rows=3)
                    -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >ANY (SELECT valn FROM it);
v	vn
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn >ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn > (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn >=ANY (SELECT valn FROM it);
v	vn
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn >=ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn >= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <ANY (SELECT valn FROM it);
v	vn
0	0
1	1
explain format=tree SELECT *
FROM ot
WHERE vn <ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn < (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn <=ANY (SELECT valn FROM it);
v	vn
0	0
1	1
2	2
explain format=tree SELECT *
FROM ot
WHERE vn <=ANY (SELECT valn FROM it);
EXPLAIN
-> Filter: <nop>((ot.vn <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.valn)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE vn =ALL (SELECT n FROM t1row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT n FROM t1row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t1row.n), true)  (rows=1)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t1row.n) or (t1row.n is null)), true)  (rows=1)
                    -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t2row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t2row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t2row.vn), true)  (rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t2row.vn) or (t2row.vn is null)), true)  (rows=2)
                    -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t3row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t3row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t3row.vn), true)  (rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t3row.vn) or (t3row.vn is null)), true)  (rows=3)
                    -> Table scan on t3row  (rows=3)

SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t4row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn =ALL (SELECT vn FROM t4row);
EXPLAIN
-> Filter: <not>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t4row.vn), true)  (rows=4)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(ot.vn) <> t4row.vn) or (t4row.vn is null)), true)  (rows=4)
                    -> Table scan on t4row  (rows=4)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT n FROM t1row);
v	vn
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT n FROM t1row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t1row.n)  (rows=1)
                -> Table scan on t1row  (rows=1)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t2row);
v	vn
0	0
1	1
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t2row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t2row.vn)  (rows=1)
                -> Table scan on t2row  (rows=2)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t3row);
v	vn
0	0
1	1
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t3row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t3row.vn)  (rows=2)
                -> Table scan on t3row  (rows=3)

SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t4row);
v	vn
0	0
1	1
2	2
3	3
explain format=tree SELECT *
FROM ot
WHERE vn <>ANY (SELECT vn FROM t4row);
EXPLAIN
-> Filter: <nop>(<in_optimizer>(ot.vn,<exists>(select #2)))  (rows=5)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: (<cache>(ot.vn) <> t4row.vn)  (rows=3)
                -> Table scan on t4row  (rows=4)

#
# Some negative testing
#
# No tables in outer query block
SELECT 1, 1 >ANY (SELECT val FROM it) AS q1, 2 >ANY (SELECT val FROM it) AS q2;
1	q1	q2
1	0	1
explain format=tree SELECT 1, 1 >ANY (SELECT val FROM it) AS q1, 2 >ANY (SELECT val FROM it) AS q2;
EXPLAIN
-> Rows fetched before execution  (rows=1)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)
-> Select #3 (subquery in projection; run only once)
    -> Aggregate: min(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT 1 WHERE 2 >ANY (SELECT val FROM it);
1
1
explain format=tree SELECT 1 WHERE 2 >ANY (SELECT val FROM it);
EXPLAIN
-> Rows fetched before execution  (rows=1)

# No tables in inner query block
SELECT 1, 1 >ANY (SELECT 0) AS q1 FROM ot;
1	q1
1	1
1	1
1	1
1	1
1	1
explain format=tree SELECT 1, 1 >ANY (SELECT 0) AS q1 FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Rows fetched before execution  (rows=1)

SELECT 1 FROM ot WHERE 1 >ANY (SELECT 0);
1
1
1
1
1
1
explain format=tree SELECT 1 FROM ot WHERE 1 >ANY (SELECT 0);
EXPLAIN
-> Table scan on ot  (rows=5)

# Set operation in subquery
SELECT v >ALL (SELECT val FROM it UNION SELECT val FROM it) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT val FROM it UNION SELECT val FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Table scan on <union temporary>  (rows=6)
        -> Union materialize with deduplication  (rows=6)
            -> Table scan on it  (rows=3)
            -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it UNION SELECT val FROM it);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it UNION SELECT val FROM it);
EXPLAIN
-> Filter: <not>((ot.v <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on <union temporary>  (rows=6)
            -> Union materialize with deduplication  (rows=6)
                -> Table scan on it  (rows=3)
                -> Table scan on it  (rows=3)

# Implicitly grouped subquery
SELECT v >ALL (SELECT MAX(val) FROM it) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT MAX(val) FROM it) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: (<cache>(ot.v) <= <ref_null_helper>(max(it.val)))  (rows=1)
            -> Aggregate: max(it.val)  (rows=1)
                -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(val) FROM it);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(val) FROM it);
EXPLAIN
-> Filter: <not>((ot.v <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

# Explicitly grouped subquery
SELECT v >ALL (SELECT val FROM it GROUP BY val) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT val FROM it GROUP BY val) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it GROUP BY val);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it GROUP BY val);
EXPLAIN
-> Filter: <not>((ot.v <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT v >ALL (SELECT MAX(valn) FROM it GROUP BY val) AS b
FROM ot;
b
0
0
0
NULL
NULL
explain format=tree SELECT v >ALL (SELECT MAX(valn) FROM it GROUP BY val) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)
        -> Filter: (<cache>(ot.v) <= <ref_null_helper>(max(it.valn)))
            -> Table scan on <temporary>
                -> Aggregate using temporary table
                    -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(valn) FROM it GROUP BY val);
v	vn
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(valn) FROM it GROUP BY val);
EXPLAIN
-> Filter: <not>((ot.v <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on <temporary>
            -> Aggregate using temporary table
                -> Table scan on it  (rows=3)

# Subquery with WINDOW function
SELECT v >ALL (SELECT MAX(val) OVER () FROM it) AS b
FROM ot;
ERROR 42000: This version of MySQL doesn't yet support 'the combination of this ALL/ANY/SOME/IN subquery with this comparison operator and with contained window functions'
SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(val) OVER () FROM it);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT MAX(val) OVER () FROM it);
EXPLAIN
-> Filter: <not>((ot.v <= <max>(select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Window aggregate with buffering: max(it.val) OVER ()   (rows=3)
            -> Table scan on it  (rows=3)

# Subquery with LIMIT (unsupported) and ORDER BY (supported)
SELECT v >ALL (SELECT val FROM it LIMIT 3) AS b
FROM ot;
ERROR 42000: This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it LIMIT 3);
ERROR 42000: This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
SELECT v >ALL (SELECT val FROM it ORDER BY val DESC) AS b
FROM ot;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT val FROM it ORDER BY val DESC) AS b
FROM ot;
EXPLAIN
-> Table scan on ot  (rows=5)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: max(it.val)  (rows=1)
        -> Table scan on it  (rows=3)

SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it ORDER BY val DESC);
v	vn
4	NULL
explain format=tree SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it ORDER BY val DESC);
EXPLAIN
-> Filter: <not>((ot.v <= (select #2)))  (rows=3.33)
    -> Table scan on ot  (rows=5)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: max(it.val)  (rows=1)
            -> Table scan on it  (rows=3)

SELECT v >ALL (SELECT val FROM it ORDER BY val DESC LIMIT 3) AS b
FROM ot;
ERROR 42000: This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
SELECT *
FROM ot
WHERE v >ALL (SELECT val FROM it ORDER BY val DESC LIMIT 3);
ERROR 42000: This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
# Subquery with outer reference in SELECT list
SELECT v >ALL (SELECT val FROM itr WHERE otr.rf = itr.rf) AS b
FROM otr
WHERE rf = 1;
b
0
0
0
0
1
explain format=tree SELECT v >ALL (SELECT val FROM itr WHERE otr.rf = itr.rf) AS b
FROM otr
WHERE rf = 1;
EXPLAIN
-> Filter: (otr.rf = 1)  (rows=1)
    -> Table scan on otr  (rows=10)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=0.333)
        -> Filter: (<cache>(otr.v) <= itr.val)  (rows=0.333)
            -> Index lookup on itr using PRIMARY (rf = otr.rf)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.otr.rf' of SELECT #2 was resolved in SELECT #1
SELECT vn >ALL (SELECT valn FROM itr WHERE otr.rf = itr.rf) AS b
FROM otr
WHERE rf = 1;
b
0
0
0
NULL
NULL
explain format=tree SELECT vn >ALL (SELECT valn FROM itr WHERE otr.rf = itr.rf) AS b
FROM otr
WHERE rf = 1;
EXPLAIN
-> Filter: (otr.rf = 1)  (rows=1)
    -> Table scan on otr  (rows=10)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(itr.valn), true)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(otr.vn) <= itr.valn) or (itr.valn is null)), true)  (rows=1)
                -> Index lookup on itr using PRIMARY (rf = otr.rf)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.otr.rf' of SELECT #2 was resolved in SELECT #1
# Subquery with outer reference in WHERE clause
SELECT *
FROM otr
WHERE v >ALL (SELECT val FROM itr WHERE otr.rf = itr.rf);
rf	v	vn
1	4	NULL
2	4	NULL
explain format=tree SELECT *
FROM otr
WHERE v >ALL (SELECT val FROM itr WHERE otr.rf = itr.rf);
EXPLAIN
-> Filter: <not>(<in_optimizer>(otr.v,<exists>(select #2)))  (rows=10)
    -> Table scan on otr  (rows=10)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=0.333)
            -> Filter: (<cache>(otr.v) <= itr.val)  (rows=0.333)
                -> Index lookup on itr using PRIMARY (rf = otr.rf)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.otr.rf' of SELECT #2 was resolved in SELECT #1
SELECT *
FROM otr
WHERE vn >ALL (SELECT valn FROM itr WHERE otr.rf = itr.rf);
rf	v	vn
explain format=tree SELECT *
FROM otr
WHERE vn >ALL (SELECT valn FROM itr WHERE otr.rf = itr.rf);
EXPLAIN
-> Filter: <not>(<in_optimizer>(otr.vn,<exists>(select #2)))  (rows=10)
    -> Table scan on otr  (rows=10)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(itr.valn), true)  (rows=1)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(otr.vn) <= itr.valn) or (itr.valn is null)), true)  (rows=1)
                    -> Index lookup on itr using PRIMARY (rf = otr.rf)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.otr.rf' of SELECT #2 was resolved in SELECT #1
set optimizer_switch=default;
DROP TABLE it, ot, itr, otr, t0row, t1row, t2row, t3row, t4row;
